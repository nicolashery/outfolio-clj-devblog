# Day 5 (2015-04-16)

A bit of a transition today: I decided to move to the frontend side of things.

What happened is I first tried to add Google OAuth to the backend with [Friend](https://github.com/cemerick/friend) and [friend-oauth2](https://github.com/ddellacosta/friend-oauth2). I briefly wanted to do it myself to learn more about sessions and OAuth, but realized it might be complex and decided to use a library, even if Friend looks like it does a lot more than I need. I ended up spending a lot of time reading up on how to use it, had trouble installing dependencies, and read that Google was changing to something called "OpenID Connect" (not sure what that is). I felt I was stalling a bit, so decided to leave the backend aside for now and start on the frontend.

I'll be using [ClojureScript](https://github.com/clojure/clojurescript) of course, and selected [Om](https://github.com/omcljs/om). I'm very curious to try things like [Reagent](http://reagent-project.github.io/), [DataScript](https://github.com/tonsky/datascript), [re-frame](https://github.com/Day8/re-frame), but given Om's popularity and the fact that I already have a lot of new things to learn, I decided to limit the number of pieces and start with that.

For tooling, I went with [Figwheel](https://github.com/bhauman/lein-figwheel) to get some of the nice "live-reload" experience. There is also [Chestnut](https://github.com/plexus/chestnut) (which uses Figwheel), but it's a little more complex so I decided to start small to understand better what was going on. I'm also running a completely separate server for now (the one that comes with Figwheel), but I saw it should be easy to merge it with my backend API server. I'll also need to properly set up "development" vs. "production" builds later (and looking at how Chestnut does it might be useful there).

Outfolio has a "demo" version with fake data that runs entirely in the browser, so I started there. I will do the integration with the "real" backend API later, when I come back to it.

It took some time to set up the different tools and dependencies before actually starting to code the app. It's quite a young area and ClojureScript is a moving target, there were a few bugs that slowed me down, but in the end I got everything working. The community seems very responsive and friendly to beginners, which is nice. Coming from JavaScript, which has a ton of tooling that changes very often, I'd say the experience here is better (taking into account the fact that it's all new to me). The live-reload sure is pretty awesome (and `defonce` makes it easy to keep your state, I don't think we have that in JS).

As Om components get bigger, the markup can get really confusing. Here I realize the benefit of React's JSX syntax, XML does seem easier to read for heavily-nested data structures like HTML (or maybe it's because we're used to it?). To improve readability, I'll probably need to break up components into smaller ones (not a bad thing to be doing anyway), limit the number of `if` or `cond`, and maybe use something like [Sablono](https://github.com/r0man/sablono) and/or [om-tools](https://github.com/Prismatic/om-tools).

Errors and stack traces can still be really confusing, sometimes discouraging. And with CLJS, there is an additional level (generated by Java, running in JavaScript), and although I know David Nolen and team have done a great job improving them, they can still be a little scary. There is also the fact that I'm not sure how to debug, and I'm probably not doing it right. Using LightTable as a scratchpad is useful, but only takes me so far. A misplaced parenthesis can have me scratching my head for a while. I'll have to figure my workflow out at some point. Maybe using an IDE like [Cursive](https://cursiveclojure.com/) could help? Also forcing myself to use Paredit can help with those misplaced parentheses.

For client-side routing, [Secretary](https://github.com/gf3/secretary) seemed to be the popular choice. It's a rather small library, so things like default routes, redirects, not found, navigating programmatically while keeping the URL updated, etc., you have to implement yourself (vs. a more complete solution like [React Router](https://github.com/rackt/react-router)), but that's fine, at least for a small app like Outfolio.

I decided to fetch data and change views directly in my route handlers for now (using the app state, like explained in [Routing with Secretary](http://yogthos.net/posts/2014-08-14-Routing-With-Secretary.html)). I might move to decoupling it using channels at some point ([Client-side Routing with Secretary](http://ayronwohletz.com/single-page-web-apps-with-a-full-clojure-stack/#Client-side_Routing_with_Secretary)).

Commit at end of day: [f1a8325](https://github.com/nicolashery/outfolio-clj/commit/f1a83256e20a683f4c6e01a25c6a2349c5f1e1d5)
